# 数据类型

Rust的数据类型有两大子集：
- Scalar
- Compound

## Scalar Types

Scalar子集里有四种数据类型：
1. 整型
2. 浮点
3. 布尔
4. 字符

### 整型

整型分为：
- 有符号，用 i 开头
- 无符号，用 u 开头

整型类型汇总：
| 长度 | 有符号 | 无符号 |
| - | - | - |
| 8-bit | i8 | u8 |
| 16-bit | i16 | u16 |
| 32-bit | i32 | u32 |
| 64-bit | i64 | u64 |
| 128-bit | i128 | u128 |
| arch | isize | usize |

关于arch：
- 取决于操作系统
- 若系统是32位，则长度为32bit
- 若系统是64位，则长度为64bit

存储范围：
- 有符号：`$-(2^{n-1})$` 至  `$(2^{n-1}-1)$`
- 无符号：`$0$` 至 `$(2^n-1)$`
- 例如，i8 的范围是 -128 至 127
- 例如，u8 的范围是 0 至 255

整型的书写方式包括三部分：
1. 类型前缀
    - 十进制：无
    - 十六进制：0x
    - 八进制：0o
    - 二进制：0b
2. 分隔符'_'
    - 目的只是为了阅读方便，例如：
    - 98_222
    - 0xf1_ed_23_01
    - 0b1101_0010
3. 类型后缀
    - 目的是为了标识该数值的大小，例如：
    - 57u8
    - 0xf1_02i64

分隔符'_'进一步说明：
- 在整型中，分隔符的作用只是为了代码阅读方便
- 对编译器来说，分隔符其实是被忽略的
- 因此，分隔符的位置并不会影响实际的数值内容
- 例如，0x0102、0x01_02、0x0_1_0_2是一样的
- 因此，我会习惯于将类型前缀、数值、类型后缀等几个要素都用分隔符分开，让阅读更清晰，例如：
```rust
let x1 = 9_888;
let x2 = 9_888_u32;
let x3 = 0x_01_02;
let x4 = 0x_01_02_i64;
let x5 = 0b_1101_0010;
let x6 = 0b_1101_0010_u8;
```

类型后缀的进一步说明：
1. 可通过后缀来标识该数值的bit大小
2. 若将数值绑定到变量，则编译器就根据该数值的后缀所标识的大小来得到变量的类型
3. 因此，若变量声明了类型，数值也有类型后缀，则变量类型和后缀类型不一致时，编译错误

如何决定使用什么类型：
- Rust对于整型数值默认为i32
- 而i32类型是运算速度最快的，即使在64位系统中
- 注意，意思就是说，即使在64位系统中，Rust默认的整型也是i32，除非使用isize或usize
- 因此，使用默认的i32整型是最好的选择

整型的溢出：
- 基于前面讨论的整形存储范围，溢出可以理解为循环
- 例如，对于u8，范围是0~255，则溢出后，256变为0，257变为1
- 例如，对于i8，范围是-128~127，则溢出后，128变为-128，129变为-1

对溢出的处理：
- Debug模式下，若发生了溢出，则运行效果就是panic
- Release模式下，则按照正常的上述溢出逻辑运行

### 浮点

Rust的浮点数基于 ==IEEE-754== 标准：
- f32，32-bit，单精度浮点数
- f64，64-bit，双精度浮点数

浮点数的书写方式：
1. 只能是十进制方式，因此不允许十六进制、八进制、二进制等类型前缀
2. 可以任意使用分隔符，与整型类型
3. 可以有类型后缀，例如：
```rust
let f0 = 2198.36;
let f1 = 2_198.36;
let f2 = 2_198.36_f32;
let f3 = 2_198.36_f64;
```

如何决定使用什么类型：
- Rust对于浮点数默认为f64
- 因为对现在的CPU来说，f64和f32的运算速度差不多，但f64能容纳更高的精度
- 因此使用默认的f64是最好的选择

### 布尔

- 关键字是 bool
- 值有 true 和 false
- 布尔型的空间大小：1个字节
- 布尔型最多的使用场景就是通过 if 进行条件判断

例如：
```rust
let b1 = true;
let b2 : bool = false;
```

### 字符

- 关键字是char，但没必要显式声明
- 使用单引号'来表示一个字符，例如'A'
- Rust的char可以表示UNICODE中的字符范围：U+0000 ~ U+D7FF , U+E000 ~ U+10FFFF，其中就包含了 zero-width 字符
- 因此字符除了ASCII外，还可以是中文字符，日文字符，emoji字符
- ==基于存储方式（UTF-8），所以Rust中char的空间大小：4个字节==

关于 zero-width 字符：
- Unicode中有一些字符叫做 zero-width ，意思就是：它是一个字符，有Unicode编码，但是没有宽度
- 通俗解释：比如在两个字符中间加入一个 zero-width 字符，则这两个字符仍然是挨在一起的，但是移动一次光标发现光标不动，因为中间有一个 zero-width 字符
- 因此，zero-width 字符并不是 ```''``` ，比如 ```let c = ''``` 是不被允许，因为 rust 没有 ```空值``` 的概念

下面是几种 zero-width 字符：
| Unicode值 | UTF-8存储值 | NAME |
| - | - | - |
| U+200B | \xe2\x80\x8b | ZERO WIDTH SPACE |
| U+200C | \xe2\x80\x8c | ZERO WIDTH NON-JOINER |
| U+200D | \xe2\x80\x8d | ZERO WIDTH JOINER |

字符的书写方式：
1. 直接通过单引号'来表示
2. 不允许类型前缀，不允许_分隔符，不允许类型后缀
3. 因为通过单引号就足以表示一个字符的信息

例如：
```rust
let c1 = 'A';
let c2 : char = 'B';
let c3 = '我';
```

可以将字符值赋值给整型，但限制如下：
1. 必须增加类型前缀'b'
2. 只支持u8类型，也就是Byte

举例：

```rust
//字符类型
let i1 = 'A';

//字符类型
let c2 : char = 'B';

//u8类型，值是65
let c3 = b'A';

//u8类型，值是65
let c4 : u8 = b'A';
```

## Compound Types

Compound子集中有两种数据类型：
1. Tuple
2. Array

### Tuple

说明：
- 使用括号表示，多个值用逗号分隔
- 各个值的数据类型可以不一致
- 例如 (1, 1.5, true, 'A')
- tuple在声明时就必须确定各个值，且一旦声明结束，空间大小就是固定的，后续不能再增大或减小

数据类型的确定：
- 基于Scalar章节的内容，若不指定数据类型，则Rust会有对应的默认数据类型
- 也可显式指定数据类型，例如 (i32, f64, bool, char)

举例：
```rust
//使用默认数据类型
let tup1 = (86, 1.2, true, '我');

//指定数据类型
let tup2 : (i16, f64, bool, char) = (86, 1.2, true, '我');

// 指定数据类型
let tup3 = (86_i128, 1.2_f64, true, '我', b'A');
```

解构Tuple的方式一：模式匹配
```rust
let tup = (500, 6.4, 1);
let (x, y, z) = tup;
println!("{} - {} - {}", x, y, z);
```

解构Tuple的方式二：下标访问
```rust
let tup = (500, 6.4, 1);
println!("{} - {} - {}", tup.0, tup.1, tup.2);
```
> 注意：下标从0开始

### Array

说明:
- 在array中的数据类型是一致的
- 声明结束后，array的大小就是固定的，不会增加也不会减小，即使array中元素的内容可能会变化
> 注意：Vector的空间大小是可变的，在Chapter8会讨论

声明语法 & 数据类型 & 元素个数：
- let a = [1,2,3,4,5]，编译器会自动推断数据类型和元素个数，当然，数据类型仍然是基于Rust默认的数据类型
- let a : [i64;5] = [1,2,3,4,5]，即显式声明数据类型和元素个数，使用';'分隔，二者都必须同时存在，且声明的元素个数必须与实际的元素个数一致

使用array的场景：
1. 元素个数确定时，例如一年的12个月的名称
2. 希望数据分配在栈上而不是堆上时

访问array中的元素：
- 由于array的内存是连续的，因此可直接通过下标访问
- 访问语法：a[0]
> 注意：下标从0开始

越界访问array元素：
- 即下标值超过数组实际大小时
- 编译期间可能是正常的
- 但运行时程序会panic
- 这与其它某些语言不一样，例如C++
- 对于Rust来说，越界访问array时的panic是一种安全的机制，而不是仍然允许访问内存进而导致内存错误

> 下面举几个有趣的越界访问array的例子，运行时都会导致panic，但在编译期间的结果提示会不同：

例：check正常，build报错
```rust
let a = [1,2,3,4,5];
println!("{}", a[6]);
```

例：check正常，build正常，运行panic
```rust
let a = [1,2,3,4,5];
let i = 6;
println!("{}", a[i]);
```